
# Contract used - Debtkernal.sol
# Events used - LogDebtOrderFilled, LogIssuanceCancelled, LogDebtOrderCancelled,
# Contract used - DebtRegistry.sol
# Events ysed - LogModifyEntryBeneficiary, LogInsertEntry,
type DebtOrder @entity {
#  collaterals: Collateral #@derivedFrom(field: "debtOrder")
#  repayment: Repayment @derivedFrom(field: "debtOrder")
  id: ID! #agreement ID
  principle: BigInt
  principleToken: Bytes
  underwriter: Bytes
  underwriterFee: BigInt
  relayer: Bytes
  relayerFee: BigInt
  cancelledBy: Bytes #from event LogIssuanceCancelled - which is never called on mainnet or kovan, so far... so it is always blank
  beneficiary: Bytes!
  underwriterRiskRating: BigInt
  termsContract: Bytes!
  termsContractParameters: Bytes!
}

# NOTE: Should not be included with entity DebtOrder. This is because a cancelled
# debt order happens before the debt order ever gets accepted, or is ever on chain.
# Contract used - DebtKernal.sol
# Events used - LogDebtOrderCancelled
type CancelledDebtOrder @entity {
  id: ID! # debtOrderHash
  cancelledBy: Bytes
}

# Contract used - ERC721Collateralizer.sol
# Events used - CollateralLocked, CollateralReturned, CollateralSeized
type Collateral @entity {
  id: ID! #agreementID
  tokenAddress: Bytes
  amount: BigInt
#  debtOrder: DebtOrder!
  status: String
  collateralReturnedTo: Bytes # this either goes to the collateralizer, or the beneficiary

}

# Contract used -  RepaymentRouter.sol
# Event used - LogRepayment
type Repayment @entity {
  id: ID!
  payers: [Bytes]
  beneficiaries: [Bytes]
  amounts: [BigInt]
  tokenAddresses: [Bytes]
  amountRepaid: BigInt
#  debtOrder: DebtOrder!
}
