
##################### main contract DebtKernal.sol
type DebtOrder @entity {
  issuance: Issuance @derivedFrom(field: "debtOrder")
  collateral: Collateral @derivedFrom(field: "debtOrder")
  repayment: Repayment @derivedFrom(field: "debtOrder")
  registered: RegisteredDebt @derivedFrom(field: "debtOrder")
  agreementID: ID!
  principle:   Int!
  principleToken: Bytes!
  underwriter: Bytes
  underWriterFee: Int
  relayer: Bytes
  relayerFee: Int
  cancelledBy: Bytes #from LogIssuanceCancelled()
}

##################### main contract DebtKernal.sol
type Issuance @entity {
  id: ID! #_agreementID
  debtOrder: DebtOrder!
  cancelledBy: Bytes # from LogIssuanceCancelle()
}


###################### main contract DebtRegistry.sol
type RegisteredDebt @entity {
  id: ID! #agreement ID
  debtOrder: DebtOrder!
  beneficiary: Bytes! #LogModifyEntryBeneficary Too
  previousBenefactors: [Bytes] #LogModifyEntryBeneficary Too
  underwriter: Bytes!
  underwriterRiskRating: BigInt!
  termsContract: Bytes!
  termsContractParameters: Bytes!

  # CAN be grabbed by the get() function
  #  version: Bytes!
  #  issuanceBlockTimestamp: BigInt!

}

###################### main contract - ERC721Collateralizer.sol
# ColateralLockedEvent() initiates the storage of this. Other two events update bools only
type Collateral @entity {
  debtor: Bytes!
  id: ID! #agreementID
  erc721Address: Bytes!
  tokenID: BigInt!
  debtOrder: DebtOrder!
  returned: Boolean! # only happens it CollateralReturn() is emitted
  seized: Boolean! # only happens if CollateralSeized() is emitted

}

###################### main contract - RepaymentRouter.sol
type Repayment @entity {
  id: ID!
  payer: Bytes!
  beneficiary: Bytes!
  amount: Int!
  tokenAddress: Bytes!
  debtOrder: DebtOrder!
}